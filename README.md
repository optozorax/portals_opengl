# Рендеринг порталов средствами OpenGL

В этом репозитории находится реализация рендеринга порталов с помощью OpenGL. Главной целью не была оптимизация, а было получение максимально корректно работающей программы при большом количестве порталов самых разных форм. Так же корректно работают поверхностные порталы.

Работающую программу можно посмотреть в секции [release](https://github.com/optozorax/portals_opengl/releases). Запуск:
`.\glut.exe <scene-name>.json`, например: `.\glut.exe simple_portals.json`. Программа запустит ту сцену, которая задана в json файле. Так же, вместо того, чтобы открывать консоль, можно пользоваться возможностями drag&drop'а, и просто навести нужную сцену на программу в проводнике.

Требования к версии OpenGL: не менее 3.0.

# Примеры сцен

Все сцены находятся в папке `scenes`.

## Два портала друг напротив друга

Файл: `simple_portals.json`.

![](img/2.png)

## Поверхностный портал

Файл: `volumetric_portal.json`.

Поверхностный портал - это портал, полученный соединением нескольких обычных порталов таким образом, что сохраняется непрерывность и целостность пространства с обоих сторон. Просто посмотрите на скриншоты, чтобы это понять. На основе этого базового концепта можно построить очень интересные порталы.

Я пока не решил, как называть данный тип портала: поверхностный или объёмный.

![](img/8.png)

## Портал, изменяющий масштаб мира

Файл: `scale_portal.json`.

![](img/15.png)

## Портал, изменяющий наклон мира

Файл: `slanted_portal.json`.

![](img/17.png)

## Пропеллер из порталов

Этот тест призван показать точность данной программы, и её способность обрабатывать нестандартные случаи рендеринга порталов. Другие подходы вряд ли могут похвастаться корректным рендерингом подобной сцены.

![](img/19.png)

# Принцип работы рендеринга

Есть множество разных подходов к рендерингу портала, первый - это подход на основе stencil буфера, в нём вся сцена внутри портала рисуется с включенным трафаретом портала, то есть в итоге отобразится только нужная часть сцены. Проблема этого подхода в том, что он неправильно работает с буфером глубины, то есть нарисовать тот же пропеллер из порталов не получится. Решают иногда эту проблему принудительным рисованием в буфер глубины нужного нам полигона.

Пример программ, использующих stencil буфер: 
* [Mini-Portal_Recursive](https://en.wikibooks.org/wiki/OpenGL_Programming/Mini-Portal_Recursive).
* [Modern tutorials](https://gitlab.com/wikibooks-opengl/modern-tutorials/tree/master/mini-portal).
* [glPortal](https://github.com/SimonLarsen/glPortal).
* [Stackoverflow - how to implement portal rendering](https://stackoverflow.com/questions/38287235/opengl-how-to-implement-portal-rendering) - моя программа справится с таким случаем
* [Rendering recursive portals with OpenGL](https://th0mas.nl/2013/05/19/rendering-recursive-portals-with-opengl/).

Другой подход - это рисовать всю сцену в framebuffer, а затем только его часть отображать на экране, при этом задавая глубину такой, как будто рисуется полигон, здесь с буфером глубины всё ок, и пропеллер нарисуется. Именно такой подход и используется в данной программе.

Помимо этого есть ещё несколько трюков, о которых далее будет рассказано поподробнее.

Для начала у нас должны быть две функции: 
* Нарисовать всю сцену: сначала рисуются порталы, затем простые полигоны.
* Нарисовать конкретный портал вместе с его содержимым.

Эти функции в процессе рекурсивно вызывают друг друга.

Основной код рендеринга порталов находится в `src/prtl_vis/opengl_common.cpp` в функциях `SceneDrawer::drawPortal` и `SceneDrawer::drawScene`.

## Работа с framebuffer'ами

Framebuffer - объект, содержащий в себе буфер глубины и буфер цвета.

Можно перенаправить рисование не на экран, а в этот фреймбуфер. Обычно это используются для пост-обработки, или чтобы показать как выглядит буфер глубины, как в [этой статье на хабре](https://habr.com/ru/post/344238/).

Примеры для framebuffer'ов находятся в файле `tests/torus.cpp`.

Главное место, где сосредоточена работа с framebuffer'ами - это файл `include/prtl_vis/framebuffer.h`.

Первое действие, которое можно производить над framebuffer'ами - это включение и выключение. При включении рисование перенаправляется на текущий фреймбуффер, а при выключении рисование перенаправляется обратно. Причем поддерживается возможность рекурсивно включать фреймбуфферы, это всё обрабатывается.

Второе действие - это нарисовать содержимое фреймбуффера на экран.

Третье действие - объединить два фреймбуффера. Каждый фреймбуффер - это не только цветная картинка, но ещё и карта глубины, поэтому их объединение заключается лишь в выборе пикселей, которые удовлетворяют тесту глубины, то есть самых ближних пикселей из двух фреймбуфферов. Это работает как магия, когда мы можем просто объединить две картинки, и они будут выглядеть так, как будто мы всё это рендерились вместе.

Четвертое, и самое главное действие для этой библиотеки, - нарисовать только ту часть фреймбуффера, которая попадает на полигон. Причем нарисовать так, чтобы в буфере глубины была не глубина из фреймбуфера (тогда такой подход ничем не будет отличаться от stencil), а глубина текущего полигона. Получается, текущий полигон выступает в роли экрана, на котором показывается мир по ту сторону портала.

Все эти операции реализуются через шейдеры.

Большое спасибо этим источникам:
* [Stackoverflow - Render the depth buffer in OpenGL without shaders](https://stackoverflow.com/questions/24266815/render-the-depth-buffer-in-opengl-without-shaders)
* [Framebuffers](https://learnopengl.com/Advanced-OpenGL/Framebuffers).
* [Tutorial 14 : Render To Texture](http://www.opengl-tutorial.org/ru/intermediate-tutorials/tutorial-14-render-to-texture/).

## Ориентация полигона по часовой стрелке и против неё. Обратная сторона портала

В OpenGL есть такое понятие, как передняя и задняя сторона. Вычисляется она при помощи определения как ориентирован спроецированный на экран полигон: по часовой стрелке или нет. В зависимости от этого определяется какую сторону полигона мы видим. К сожалению, алгоритм этого определения не такой тривиальный, как хотелось бы, и если представить более-менее сложный полигон, то вообще становится непонятно что тут ориентация по часовой стрелке, а что против неё. Спасибо [stackoverflow](https://stackoverflow.com/questions/14505565/detect-if-a-set-of-points-in-an-array-that-are-the-vertices-of-a-complex-polygon) за готовый алгоритм. 

Для проецирования полигона используется функция `include/prtl_vis/opengl_common.h`:`projectPolygonToScreen`.

Для определения ориентации полигона используется функция `include/prtl_vis/opengl_common.h`:`isPolygonOrientedClockwise`.

И для того, чтобы не рисовать лишний раз портал, когда мы видим его заднюю сторону, используется эта функция. Это не только увеличивает производительность, но и избавляет от лишней головной боли, как бы показать заднюю сторону портала, подставив туда очень близко полигон.

Так же это обязательно делать в таком случае: мы смотрим на синий портал, видим из него мир, и в этом мире рекурсивно рисуем все порталы, в частности мы решили нарисовать оранжевый портал. А оранжевый портал находится для нас в том же месте, что и синий, после преобразования координат. И получается, что вместо того, чтобы увидеть всю сцену через синий портал, мы увидим только заднюю часть оранжевого портала. Именно для того, чтобы это не случалось, и используется данная процедура проверки на заднюю и переднюю сторону.

Ну, или, окей, вы можете поставить костыль, чтобы не рисовалась оранжевый портал внутри мира синего портала, когда мы на него смотрим. Но этот костыль уже не сработает при рисовании поверхностного портала, и там это вылезет в таком же виде. И там новый костыль не поставишь, потому что поверхностные порталы могут иметь миллион различных конфигураций.

При рисовании портала всегда делается эта проверка.

## Тесселяция полигонов

В OpenGL с помощью `glBegin(GL_POLYGON)` можно нарисовать только выпуклый полигон. Поэтому никаких сложных полигонов в виде буквы С. 

Именно для того чтобы нарисовать их, используется тесселяция. Большое спасибо [этому сайту](http://www.songho.ca/opengl/gl_tessellation.html), на основе которого сделана тесселяция в этом проекте.

Для работы с тесселированными полигонами имеется файл `include/prtl_vis/fragment.h`. Там можно не только разбить полигон на примитивы, но ещё и учитывать координаты текстуры. Так же там же можно нарисовать эти штуки.

## ClipPlane

![](img/bug1.png)

Представим, что мы смотрим на синий портал, а за оранжевым у нас находится полигон. Теперь представим, что мы нарисовали содержимое синего портала, но почему-то мы видим этот полигон, хотя он содержится за порталом. Это проблема того, что мы видим те объекты, которые не должны видеть. Тут нам на помощь приходит clip plane - плоскость, обрезающая всю геометрию на два полупространства. Ставим такую плоскость, чтобы она оставляла только то, что находится по ту сторону плоскости портала, и мы больше не видим лишних полигонов.

Но мы ограничены в этих плоскостях, поэтому будем использовать одновременно только одну.

Специально для этого есть файл `include/prtl_vis/plane.h`, там есть возможность рекурсивно включать и выключать обрезающие плоскости. Сделано аналогично framebuffer'ам.

Так же нам при рисовании порталов надо учитывать обрезающую плоскость. Это учитывается в коде шейдера рисования фреймбуфера полигоном, так что всё хорошо. Кстати, не учитывания этого тоже создавало множество багов и артефактов :)

## Преобразования координат

У нас есть исходная сцена. Как нам получить сцену, которую мы увидим сквозь портал? Применить к ней преобразования координат! Порталы по сути есть простые преобразования координат, которые смещают и поворачивают сцену. А если вдаваться в подробности, то сначала вся сцена записывается в относительных координатах первого портала, а затем переводится из относительных координат второго портала в абсолютные.

Поэтому каждый раз при рисовании того или иного портала к модельно-видовой матрице применяются преобразования координат. А после работы с текущим порталом, применяется обратная матрица преобразования координат, чтобы вернуть всё к прежнему виду.

Для преобразования координат используется библиотека `glm`, а для работы с осями координат и получения матриц библиотека `spob`.

## Оптимизация с помощью алгоритмов объединения полигонов

Самая дорогая операция - нарисовать портал. Потому что при рисовании потрала в нём есть не только вся сцена, но ещё и другие порталы, которые рекурсивно рисуются. Поэтому мы должны любыми способами отсекать те порталы, которые заведомо не будут видны на экране. По-любому выиграем в скорости работы.

Именно так и делается в программе. При рисовании каждого портала определяется текущая видимая область. При помощи библиотеки `clipper` находится объединение этой области с спроецированным полигоном портала, благодаря чему можно определить, когда эта область нулевая и просто не рисовать не видимый портал.

Это дает значительный прирос производительности, несмотря на то, что операция нахождения пересечения полигонов - очень дорогая.

Конечно, можно ещё сделать такую оптимизацию, чтобы из полигона видимости ещё вычитался полигон, который перекрывает портал на экране. Но в этой программе такое не реализовано.

## Интеграция всего этого = лакомое место для багов

Окей, мы собрали все эти вещи вместе, но все-равно получается какая-то фигня :( Это всё, потому что когда мы активировали обрезающую плоскость, у нас была одна система координат, а когда возвращали её, другая. Это ломало всё, и долгое время было очень серьезным багом. Но спасибо создателям дебага в Visual Studio, это удалось найти. Так что не делайте таких ошибок и используйте этот код.

Или, например, у нас могут быть порталы, которые преобразуют всю сцену таким образом, что полигоны, ориентированные по часовой стрелке, вдруг становятся ориентированными против часовой стрелки О_о, и у нас задняя сторона становится передней. Для этого используется специальный флаг `clockWiseInvert` при рендеринге порталов.

*Вывод:* порталы, одна из самых коварных вещей, что я встречал в своей жизни, и они создают баги на пустом месте. Благо в этом репозитории вроде всё работает хорошо... И то я уже ничему не верю, и ни на что не надеюсь. Если захотите рендерить порталы такой же сложности как у меня, то используйте мой код, либо просто переходите на рейтрейсинг. Вот какой черт вас укусил делать порталы на OpenGL? Рейтрейсить порталы - сплошное удовольствие, простое как два пальца. Пользуйтесь мощностью своих видеокарт.

[OpenGL Ray Tracer With Portals Demo](https://www.youtube.com/watch?v=dPdo1MLewaU).

# Компиляция

Зависимости: [glm](https://glm.g-truc.net/0.9.9/index.html), [glew](http://glew.sourceforge.net/), [glut](http://freeglut.sourceforge.net/), [spob](https://github.com/optozorax/space_objects), [clipper](http://www.angusj.com/delphi/clipper.php).

Линкуете все файлы из папки `src` с файлом `main.cpp`, считая папку `include` как включаемый каталог (в gcc это опция: `-Iinclude`).

Шейдеры, необходимые для запуска программы находятся в папке `glsl`, её содержимое необходимо поместить в одну папку с программой.

# TODO

- [ ] Makefile
- [ ] Framebuffer multisample
- [ ] Translate to English
- [ ] Написать этот файл с объяснениями по-человечески, желательно с картинками.